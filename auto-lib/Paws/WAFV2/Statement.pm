# Generated by default/object.tt
package Paws::WAFV2::Statement;
  use Moose;
  has AndStatement => (is => 'ro', isa => 'Paws::WAFV2::AndStatement');
  has ByteMatchStatement => (is => 'ro', isa => 'Paws::WAFV2::ByteMatchStatement');
  has GeoMatchStatement => (is => 'ro', isa => 'Paws::WAFV2::GeoMatchStatement');
  has IPSetReferenceStatement => (is => 'ro', isa => 'Paws::WAFV2::IPSetReferenceStatement');
  has LabelMatchStatement => (is => 'ro', isa => 'Paws::WAFV2::LabelMatchStatement');
  has ManagedRuleGroupStatement => (is => 'ro', isa => 'Paws::WAFV2::ManagedRuleGroupStatement');
  has NotStatement => (is => 'ro', isa => 'Paws::WAFV2::NotStatement');
  has OrStatement => (is => 'ro', isa => 'Paws::WAFV2::OrStatement');
  has RateBasedStatement => (is => 'ro', isa => 'Paws::WAFV2::RateBasedStatement');
  has RegexMatchStatement => (is => 'ro', isa => 'Paws::WAFV2::RegexMatchStatement');
  has RegexPatternSetReferenceStatement => (is => 'ro', isa => 'Paws::WAFV2::RegexPatternSetReferenceStatement');
  has RuleGroupReferenceStatement => (is => 'ro', isa => 'Paws::WAFV2::RuleGroupReferenceStatement');
  has SizeConstraintStatement => (is => 'ro', isa => 'Paws::WAFV2::SizeConstraintStatement');
  has SqliMatchStatement => (is => 'ro', isa => 'Paws::WAFV2::SqliMatchStatement');
  has XssMatchStatement => (is => 'ro', isa => 'Paws::WAFV2::XssMatchStatement');

1;

### main pod documentation begin ###

=head1 NAME

Paws::WAFV2::Statement

=head1 USAGE

This class represents one of two things:

=head3 Arguments in a call to a service

Use the attributes of this class as arguments to methods. You shouldn't make instances of this class. 
Each attribute should be used as a named argument in the calls that expect this type of object.

As an example, if Att1 is expected to be a Paws::WAFV2::Statement object:

  $service_obj->Method(Att1 => { AndStatement => $value, ..., XssMatchStatement => $value  });

=head3 Results returned from an API call

Use accessors for each attribute. If Att1 is expected to be an Paws::WAFV2::Statement object:

  $result = $service_obj->Method(...);
  $result->Att1->AndStatement

=head1 DESCRIPTION

The processing guidance for a Rule, used by WAF to determine whether a
web request matches the rule.

For example specifications, see the examples section of CreateWebACL.

=head1 ATTRIBUTES


=head2 AndStatement => L<Paws::WAFV2::AndStatement>

A logical rule statement used to combine other rule statements with AND
logic. You provide more than one Statement within the C<AndStatement>.


=head2 ByteMatchStatement => L<Paws::WAFV2::ByteMatchStatement>

A rule statement that defines a string match search for WAF to apply to
web requests. The byte match statement provides the bytes to search
for, the location in requests that you want WAF to search, and other
settings. The bytes to search for are typically a string that
corresponds with ASCII characters. In the WAF console and the developer
guide, this is called a string match statement.


=head2 GeoMatchStatement => L<Paws::WAFV2::GeoMatchStatement>

A rule statement that labels web requests by country and region and
that matches against web requests based on country code. A geo match
rule labels every request that it inspects regardless of whether it
finds a match.

=over

=item *

To manage requests only by country, you can use this statement by
itself and specify the countries that you want to match against in the
C<CountryCodes> array.

=item *

Otherwise, configure your geo match rule with Count action so that it
only labels requests. Then, add one or more label match rules to run
after the geo match rule and configure them to match against the
geographic labels and handle the requests as needed.

=back

WAF labels requests using the alpha-2 country and region codes from the
International Organization for Standardization (ISO) 3166 standard. WAF
determines the codes using either the IP address in the web request
origin or, if you specify it, the address in the geo match
C<ForwardedIPConfig>.

If you use the web request origin, the label formats are
C<awswaf:clientip:geo:region:E<lt>ISO country codeE<gt>-E<lt>ISO region
codeE<gt>> and C<awswaf:clientip:geo:country:E<lt>ISO country
codeE<gt>>.

If you use a forwarded IP address, the label formats are
C<awswaf:forwardedip:geo:region:E<lt>ISO country codeE<gt>-E<lt>ISO
region codeE<gt>> and C<awswaf:forwardedip:geo:country:E<lt>ISO country
codeE<gt>>.

For additional details, see Geographic match rule statement
(https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-type-geo-match.html)
in the WAF Developer Guide
(https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html).


=head2 IPSetReferenceStatement => L<Paws::WAFV2::IPSetReferenceStatement>

A rule statement used to detect web requests coming from particular IP
addresses or address ranges. To use this, create an IPSet that
specifies the addresses you want to detect, then use the ARN of that
set in this statement. To create an IP set, see CreateIPSet.

Each IP set rule statement references an IP set. You create and
maintain the set independent of your rules. This allows you to use the
single set in multiple rules. When you update the referenced set, WAF
automatically updates all rules that reference it.


=head2 LabelMatchStatement => L<Paws::WAFV2::LabelMatchStatement>

A rule statement to match against labels that have been added to the
web request by rules that have already run in the web ACL.

The label match statement provides the label or namespace string to
search for. The label string can represent a part or all of the fully
qualified label name that had been added to the web request. Fully
qualified labels have a prefix, optional namespaces, and label name.
The prefix identifies the rule group or web ACL context of the rule
that added the label. If you do not provide the fully qualified name in
your label match string, WAF performs the search for labels that were
added in the same context as the label match statement.


=head2 ManagedRuleGroupStatement => L<Paws::WAFV2::ManagedRuleGroupStatement>

A rule statement used to run the rules that are defined in a managed
rule group. To use this, provide the vendor name and the name of the
rule group in this statement. You can retrieve the required names by
calling ListAvailableManagedRuleGroups.

You cannot nest a C<ManagedRuleGroupStatement>, for example for use
inside a C<NotStatement> or C<OrStatement>. You cannot use a managed
rule group inside another rule group. You can only reference a managed
rule group as a top-level statement within a rule that you define in a
web ACL.

You are charged additional fees when you use the WAF Bot Control
managed rule group C<AWSManagedRulesBotControlRuleSet>, the WAF Fraud
Control account takeover prevention (ATP) managed rule group
C<AWSManagedRulesATPRuleSet>, or the WAF Fraud Control account creation
fraud prevention (ACFP) managed rule group
C<AWSManagedRulesACFPRuleSet>. For more information, see WAF Pricing
(http://aws.amazon.com/waf/pricing/).


=head2 NotStatement => L<Paws::WAFV2::NotStatement>

A logical rule statement used to negate the results of another rule
statement. You provide one Statement within the C<NotStatement>.


=head2 OrStatement => L<Paws::WAFV2::OrStatement>

A logical rule statement used to combine other rule statements with OR
logic. You provide more than one Statement within the C<OrStatement>.


=head2 RateBasedStatement => L<Paws::WAFV2::RateBasedStatement>

A rate-based rule counts incoming requests and rate limits requests
when they are coming at too fast a rate. The rule categorizes requests
according to your aggregation criteria, collects them into aggregation
instances, and counts and rate limits the requests for each instance.

If you change any of these settings in a rule that's currently in use,
the change resets the rule's rate limiting counts. This can pause the
rule's rate limiting activities for up to a minute.

You can specify individual aggregation keys, like IP address or HTTP
method. You can also specify aggregation key combinations, like IP
address and HTTP method, or HTTP method, query argument, and cookie.

Each unique set of values for the aggregation keys that you specify is
a separate aggregation instance, with the value from each key
contributing to the aggregation instance definition.

For example, assume the rule evaluates web requests with the following
IP address and HTTP method values:

=over

=item *

IP address 10.1.1.1, HTTP method POST

=item *

IP address 10.1.1.1, HTTP method GET

=item *

IP address 127.0.0.0, HTTP method POST

=item *

IP address 10.1.1.1, HTTP method GET

=back

The rule would create different aggregation instances according to your
aggregation criteria, for example:

=over

=item *

If the aggregation criteria is just the IP address, then each
individual address is an aggregation instance, and WAF counts requests
separately for each. The aggregation instances and request counts for
our example would be the following:

=over

=item *

IP address 10.1.1.1: count 3

=item *

IP address 127.0.0.0: count 1

=back

=item *

If the aggregation criteria is HTTP method, then each individual HTTP
method is an aggregation instance. The aggregation instances and
request counts for our example would be the following:

=over

=item *

HTTP method POST: count 2

=item *

HTTP method GET: count 2

=back

=item *

If the aggregation criteria is IP address and HTTP method, then each IP
address and each HTTP method would contribute to the combined
aggregation instance. The aggregation instances and request counts for
our example would be the following:

=over

=item *

IP address 10.1.1.1, HTTP method POST: count 1

=item *

IP address 10.1.1.1, HTTP method GET: count 2

=item *

IP address 127.0.0.0, HTTP method POST: count 1

=back

=back

For any n-tuple of aggregation keys, each unique combination of values
for the keys defines a separate aggregation instance, which WAF counts
and rate-limits individually.

You can optionally nest another statement inside the rate-based
statement, to narrow the scope of the rule so that it only counts and
rate limits requests that match the nested statement. You can use this
nested scope-down statement in conjunction with your aggregation key
specifications or you can just count and rate limit all requests that
match the scope-down statement, without additional aggregation. When
you choose to just manage all requests that match a scope-down
statement, the aggregation instance is singular for the rule.

You cannot nest a C<RateBasedStatement> inside another statement, for
example inside a C<NotStatement> or C<OrStatement>. You can define a
C<RateBasedStatement> inside a web ACL and inside a rule group.

For additional information about the options, see Rate limiting web
requests using rate-based rules
(https://docs.aws.amazon.com/waf/latest/developerguide/waf-rate-based-rules.html)
in the I<WAF Developer Guide>.

If you only aggregate on the individual IP address or forwarded IP
address, you can retrieve the list of IP addresses that WAF is
currently rate limiting for a rule through the API call
C<GetRateBasedStatementManagedKeys>. This option is not available for
other aggregation configurations.

WAF tracks and manages web requests separately for each instance of a
rate-based rule that you use. For example, if you provide the same
rate-based rule settings in two web ACLs, each of the two rule
statements represents a separate instance of the rate-based rule and
gets its own tracking and management by WAF. If you define a rate-based
rule inside a rule group, and then use that rule group in multiple
places, each use creates a separate instance of the rate-based rule
that gets its own tracking and management by WAF.


=head2 RegexMatchStatement => L<Paws::WAFV2::RegexMatchStatement>

A rule statement used to search web request components for a match
against a single regular expression.


=head2 RegexPatternSetReferenceStatement => L<Paws::WAFV2::RegexPatternSetReferenceStatement>

A rule statement used to search web request components for matches with
regular expressions. To use this, create a RegexPatternSet that
specifies the expressions that you want to detect, then use the ARN of
that set in this statement. A web request matches the pattern set rule
statement if the request component matches any of the patterns in the
set. To create a regex pattern set, see CreateRegexPatternSet.

Each regex pattern set rule statement references a regex pattern set.
You create and maintain the set independent of your rules. This allows
you to use the single set in multiple rules. When you update the
referenced set, WAF automatically updates all rules that reference it.


=head2 RuleGroupReferenceStatement => L<Paws::WAFV2::RuleGroupReferenceStatement>

A rule statement used to run the rules that are defined in a RuleGroup.
To use this, create a rule group with your rules, then provide the ARN
of the rule group in this statement.

You cannot nest a C<RuleGroupReferenceStatement>, for example for use
inside a C<NotStatement> or C<OrStatement>. You cannot use a rule group
reference statement inside another rule group. You can only reference a
rule group as a top-level statement within a rule that you define in a
web ACL.


=head2 SizeConstraintStatement => L<Paws::WAFV2::SizeConstraintStatement>

A rule statement that compares a number of bytes against the size of a
request component, using a comparison operator, such as greater than
(E<gt>) or less than (E<lt>). For example, you can use a size
constraint statement to look for query strings that are longer than 100
bytes.

If you configure WAF to inspect the request body, WAF inspects only the
number of bytes in the body up to the limit for the web ACL and
protected resource type. If you know that the request body for your web
requests should never exceed the inspection limit, you can use a size
constraint statement to block requests that have a larger request body
size. For more information about the inspection limits, see C<Body> and
C<JsonBody> settings for the C<FieldToMatch> data type.

If you choose URI for the value of Part of the request to filter on,
the slash (/) in the URI counts as one character. For example, the URI
C</logo.jpg> is nine characters long.


=head2 SqliMatchStatement => L<Paws::WAFV2::SqliMatchStatement>

A rule statement that inspects for malicious SQL code. Attackers insert
malicious SQL code into web requests to do things like modify your
database or extract data from it.


=head2 XssMatchStatement => L<Paws::WAFV2::XssMatchStatement>

A rule statement that inspects for cross-site scripting (XSS) attacks.
In XSS attacks, the attacker uses vulnerabilities in a benign website
as a vehicle to inject malicious client-site scripts into other
legitimate web browsers.



=head1 SEE ALSO

This class forms part of L<Paws>, describing an object used in L<Paws::WAFV2>

=head1 BUGS and CONTRIBUTIONS

The source code is located here: L<https://github.com/pplu/aws-sdk-perl>

Please report bugs to: L<https://github.com/pplu/aws-sdk-perl/issues>

=cut

