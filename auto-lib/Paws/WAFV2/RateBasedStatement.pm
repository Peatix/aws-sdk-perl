# Generated by default/object.tt
package Paws::WAFV2::RateBasedStatement;
  use Moose;
  has AggregateKeyType => (is => 'ro', isa => 'Str', required => 1);
  has CustomKeys => (is => 'ro', isa => 'ArrayRef[Paws::WAFV2::RateBasedStatementCustomKey]');
  has EvaluationWindowSec => (is => 'ro', isa => 'Int');
  has ForwardedIPConfig => (is => 'ro', isa => 'Paws::WAFV2::ForwardedIPConfig');
  has Limit => (is => 'ro', isa => 'Int', required => 1);
  has ScopeDownStatement => (is => 'ro', isa => 'Paws::WAFV2::Statement');

1;

### main pod documentation begin ###

=head1 NAME

Paws::WAFV2::RateBasedStatement

=head1 USAGE

This class represents one of two things:

=head3 Arguments in a call to a service

Use the attributes of this class as arguments to methods. You shouldn't make instances of this class. 
Each attribute should be used as a named argument in the calls that expect this type of object.

As an example, if Att1 is expected to be a Paws::WAFV2::RateBasedStatement object:

  $service_obj->Method(Att1 => { AggregateKeyType => $value, ..., ScopeDownStatement => $value  });

=head3 Results returned from an API call

Use accessors for each attribute. If Att1 is expected to be an Paws::WAFV2::RateBasedStatement object:

  $result = $service_obj->Method(...);
  $result->Att1->AggregateKeyType

=head1 DESCRIPTION

A rate-based rule counts incoming requests and rate limits requests
when they are coming at too fast a rate. The rule categorizes requests
according to your aggregation criteria, collects them into aggregation
instances, and counts and rate limits the requests for each instance.

If you change any of these settings in a rule that's currently in use,
the change resets the rule's rate limiting counts. This can pause the
rule's rate limiting activities for up to a minute.

You can specify individual aggregation keys, like IP address or HTTP
method. You can also specify aggregation key combinations, like IP
address and HTTP method, or HTTP method, query argument, and cookie.

Each unique set of values for the aggregation keys that you specify is
a separate aggregation instance, with the value from each key
contributing to the aggregation instance definition.

For example, assume the rule evaluates web requests with the following
IP address and HTTP method values:

=over

=item *

IP address 10.1.1.1, HTTP method POST

=item *

IP address 10.1.1.1, HTTP method GET

=item *

IP address 127.0.0.0, HTTP method POST

=item *

IP address 10.1.1.1, HTTP method GET

=back

The rule would create different aggregation instances according to your
aggregation criteria, for example:

=over

=item *

If the aggregation criteria is just the IP address, then each
individual address is an aggregation instance, and WAF counts requests
separately for each. The aggregation instances and request counts for
our example would be the following:

=over

=item *

IP address 10.1.1.1: count 3

=item *

IP address 127.0.0.0: count 1

=back

=item *

If the aggregation criteria is HTTP method, then each individual HTTP
method is an aggregation instance. The aggregation instances and
request counts for our example would be the following:

=over

=item *

HTTP method POST: count 2

=item *

HTTP method GET: count 2

=back

=item *

If the aggregation criteria is IP address and HTTP method, then each IP
address and each HTTP method would contribute to the combined
aggregation instance. The aggregation instances and request counts for
our example would be the following:

=over

=item *

IP address 10.1.1.1, HTTP method POST: count 1

=item *

IP address 10.1.1.1, HTTP method GET: count 2

=item *

IP address 127.0.0.0, HTTP method POST: count 1

=back

=back

For any n-tuple of aggregation keys, each unique combination of values
for the keys defines a separate aggregation instance, which WAF counts
and rate-limits individually.

You can optionally nest another statement inside the rate-based
statement, to narrow the scope of the rule so that it only counts and
rate limits requests that match the nested statement. You can use this
nested scope-down statement in conjunction with your aggregation key
specifications or you can just count and rate limit all requests that
match the scope-down statement, without additional aggregation. When
you choose to just manage all requests that match a scope-down
statement, the aggregation instance is singular for the rule.

You cannot nest a C<RateBasedStatement> inside another statement, for
example inside a C<NotStatement> or C<OrStatement>. You can define a
C<RateBasedStatement> inside a web ACL and inside a rule group.

For additional information about the options, see Rate limiting web
requests using rate-based rules
(https://docs.aws.amazon.com/waf/latest/developerguide/waf-rate-based-rules.html)
in the I<WAF Developer Guide>.

If you only aggregate on the individual IP address or forwarded IP
address, you can retrieve the list of IP addresses that WAF is
currently rate limiting for a rule through the API call
C<GetRateBasedStatementManagedKeys>. This option is not available for
other aggregation configurations.

WAF tracks and manages web requests separately for each instance of a
rate-based rule that you use. For example, if you provide the same
rate-based rule settings in two web ACLs, each of the two rule
statements represents a separate instance of the rate-based rule and
gets its own tracking and management by WAF. If you define a rate-based
rule inside a rule group, and then use that rule group in multiple
places, each use creates a separate instance of the rate-based rule
that gets its own tracking and management by WAF.

=head1 ATTRIBUTES


=head2 B<REQUIRED> AggregateKeyType => Str

Setting that indicates how to aggregate the request counts.

Web requests that are missing any of the components specified in the
aggregation keys are omitted from the rate-based rule evaluation and
handling.

=over

=item *

C<CONSTANT> - Count and limit the requests that match the rate-based
rule's scope-down statement. With this option, the counted requests
aren't further aggregated. The scope-down statement is the only
specification used. When the count of all requests that satisfy the
scope-down statement goes over the limit, WAF applies the rule action
to all requests that satisfy the scope-down statement.

With this option, you must configure the C<ScopeDownStatement>
property.

=item *

C<CUSTOM_KEYS> - Aggregate the request counts using one or more web
request components as the aggregate keys.

With this option, you must specify the aggregate keys in the
C<CustomKeys> property.

To aggregate on only the IP address or only the forwarded IP address,
don't use custom keys. Instead, set the aggregate key type to C<IP> or
C<FORWARDED_IP>.

=item *

C<FORWARDED_IP> - Aggregate the request counts on the first IP address
in an HTTP header.

With this option, you must specify the header to use in the
C<ForwardedIPConfig> property.

To aggregate on a combination of the forwarded IP address with other
aggregate keys, use C<CUSTOM_KEYS>.

=item *

C<IP> - Aggregate the request counts on the IP address from the web
request origin.

To aggregate on a combination of the IP address with other aggregate
keys, use C<CUSTOM_KEYS>.

=back



=head2 CustomKeys => ArrayRef[L<Paws::WAFV2::RateBasedStatementCustomKey>]

Specifies the aggregate keys to use in a rate-base rule.


=head2 EvaluationWindowSec => Int

The amount of time, in seconds, that WAF should include in its request
counts, looking back from the current time. For example, for a setting
of 120, when WAF checks the rate, it counts the requests for the 2
minutes immediately preceding the current time. Valid settings are 60,
120, 300, and 600.

This setting doesn't determine how often WAF checks the rate, but how
far back it looks each time it checks. WAF checks the rate about every
10 seconds.

Default: C<300> (5 minutes)


=head2 ForwardedIPConfig => L<Paws::WAFV2::ForwardedIPConfig>

The configuration for inspecting IP addresses in an HTTP header that
you specify, instead of using the IP address that's reported by the web
request origin. Commonly, this is the X-Forwarded-For (XFF) header, but
you can specify any header name.

If the specified header isn't present in the request, WAF doesn't apply
the rule to the web request at all.

This is required if you specify a forwarded IP in the rule's aggregate
key settings.


=head2 B<REQUIRED> Limit => Int

The limit on requests during the specified evaluation window for a
single aggregation instance for the rate-based rule. If the rate-based
statement includes a C<ScopeDownStatement>, this limit is applied only
to the requests that match the statement.

Examples:

=over

=item *

If you aggregate on just the IP address, this is the limit on requests
from any single IP address.

=item *

If you aggregate on the HTTP method and the query argument name "city",
then this is the limit on requests for any single method, city pair.

=back



=head2 ScopeDownStatement => L<Paws::WAFV2::Statement>

An optional nested statement that narrows the scope of the web requests
that are evaluated and managed by the rate-based statement. When you
use a scope-down statement, the rate-based rule only tracks and rate
limits requests that match the scope-down statement. You can use any
nestable Statement in the scope-down statement, and you can nest
statements at any level, the same as you can for a rule statement.



=head1 SEE ALSO

This class forms part of L<Paws>, describing an object used in L<Paws::WAFV2>

=head1 BUGS and CONTRIBUTIONS

The source code is located here: L<https://github.com/pplu/aws-sdk-perl>

Please report bugs to: L<https://github.com/pplu/aws-sdk-perl/issues>

=cut

